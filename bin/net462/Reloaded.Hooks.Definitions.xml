<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Reloaded.Hooks.Definitions</name>
    </assembly>
    <members>
        <member name="T:Reloaded.Hooks.Definitions.AsmHookOptions">
            <summary>
            Defines common options which can be used for assembly hooks.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.AsmHookOptions.PreferRelativeJump">
            <summary>
            Tries to use a relative jump e.g. "jmp 0x123456" instead of absolute (pointer based)
            jump "jmp [0x123456]" when possible at the beginning of the hooked function. This is sometimes
            useful when patching over a function and you believe the built in function patcher
            is not picking up the return address.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.AsmHookOptions.Behaviour">
            <summary>
            Defines what should be done with the original code that was replaced with the JMP instruction.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.AsmHookOptions.hookLength">
            <summary>
            Optional explicit length of hook.
            Use only in rare cases where auto-length check overflows a jmp/call opcode.
            Default is -1 (Automatic).
            See <see cref="P:Reloaded.Hooks.Definitions.AsmHookOptions.MaxOpcodeSize"/> which defines the minimum autogenerated hook length.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.AsmHookOptions.MaxOpcodeSize">
            <summary>
            Maximum size of the jmp opcode generated to the stub function.
            This is the minimum bytes overwritten at the point where the hook you are making is being made.
            Default value is 7 (for backwards compatibility).
            If <see cref="P:Reloaded.Hooks.Definitions.AsmHookOptions.PreferRelativeJump"/> is false, use a value of 6.
            If <see cref="P:Reloaded.Hooks.Definitions.AsmHookOptions.PreferRelativeJump"/> is true, you can use a value of 5.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour">
            <summary>
            Defines the behaviour used by the <see cref="T:Reloaded.Hooks.Definitions.IAsmHook"/>
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour.ExecuteFirst">
            <summary>
            Executes your assembly code before the original.
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour.ExecuteAfter">
            <summary>
            Executes your assembly code after the original.
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour.DoNotExecuteOriginal">
            <summary>
            Do not execute original replaced code. (Dangerous!)
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.FunctionHookOptions">
            <summary>
            Defines common options which can be used for function hooks.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.FunctionHookOptions.PreferRelativeJump">
            <summary>
            Tries to use a relative jump e.g. "jmp 0x123456" instead of absolute (pointer based)
            jump "jmp [0x123456]" when possible at the beginning of the hooked function. This is sometimes
            useful when patching over a function and you believe the built in function patcher
            is not picking up the return address.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.FunctionHookOptions.SearchInModules">
             <summary>
             [Related To: Function Patcher]
             If true, when patching return addresses for hooks, searches other modules' (DLLs) code
             for the original bytes to patch.
            
             [Note: Enabling this hurts performance and is very rarely needed.]
             </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.FunctionHookOptions.VerifyJumpTargetsModule">
             <summary>
             [Related To: Function Patcher] 
             If true, check if existing hook jumps in the function prologue don't point to a valid module.
             If they point to a module, this indicates the jmp was probably part of the original program code and is not a hook.
            
             [Note: Enabling this hurts performance and is very rarely needed.]
             </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.Helpers.AddressExtensions">
            <summary>
            Useful extensions for dealing with memory addresses.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.Helpers.AddressExtensions.ToUnsigned(System.Int64)">
            <summary>
            Converts a signed long to an unsigned long.
            </summary>
            <param name="value">The value to convert.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.Helpers.AddressExtensions.ToUnsigned(System.IntPtr)">
            <summary>
            Converts a signed nint/IntPtr to a native unsigned value.
            </summary>
            <param name="value">The value to convert.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.Helpers.AddressExtensions.ToSigned(System.UIntPtr)">
            <summary>
            Converts an unsigned nuint/UIntPtr to a native signed value.
            </summary>
            <param name="value">The value to convert.</param>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.IAsmHook">
            <summary>
            Represents an individual x86/x64 Cheat Engine style assembly hook.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IAsmHook.IsEnabled">
            <summary>
            True if the hook is enabled, else false.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IAsmHook.Activate">
            <summary>
            Performs a one time activation of the hook.
            This function should only ever be called once.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IAsmHook.Enable">
            <summary>
            Enables the current hook if it is disabled.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IAsmHook.Disable">
            <summary>
            Disables the current hook if it is enabled.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.IFunction`1">
            <summary>
            An interface for performing operations on native functions in memory.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IFunction`1.Address">
            <summary>
            Address of the function in memory.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IFunction`1.Hooks">
            <summary>
            Provides an interface to the hooks library.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.Hook(`0,System.Int32)">
            <summary>
            Creates a hook for a function at a given address.
            </summary>
            <param name="function">The function to detour the original function to.</param>
            <param name="minHookLength">Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.Hook(`0)">
            <summary>
            Creates a hook for a function at a given address.
            </summary>
            <param name="function">The function to detour the original function to.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.Hook(System.Void*,System.Int32)">
            <summary>
            Creates a hook for a function at a given address.
            </summary>
            <param name="function">The function to detour the original function to.</param>
            <param name="minHookLength">Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.Hook(System.Void*)">
            <summary>
            Creates a hook for a function at a given address.
            </summary>
            <param name="function">The function to detour the original function to.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.Hook(System.Type,System.String,System.Int32)">
            <summary>
            Creates a hook for a function at a given address.
            Use only in .NET 5 and above with methods declared [UnmanagedCallersOnly].
            </summary>
            <param name="type">The type containing the method. Use "typeof()"</param>
            <param name="methodName">The name of the method. Use nameof()</param>
            <param name="minHookLength">Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.Hook(System.Type,System.String)">
            <summary>
            Creates a hook for a function at a given address.
            Use only in .NET 5 and above with methods declared [UnmanagedCallersOnly].
            </summary>
            <param name="type">The type containing the method. Use "typeof()"</param>
            <param name="methodName">The name of the method. Use nameof()</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.HookAs``1(System.Void*,System.Int32)">
            <summary>
            Creates a hook for this function using an alternative delegate/function pointer specified by <typeparamref name="TFunctionType"/>.
            </summary>
            <param name="function">The function to detour the original function to.</param>
            <param name="minHookLength">Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.HookAs``1(System.Void*)">
            <summary>
            Creates a hook for this function using an alternative delegate/function pointer specified by <typeparamref name="TFunctionType"/>.
            </summary>
            <param name="function">The function to detour the original function to.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.HookAs``1(System.Type,System.String,System.Int32)">
            <summary>
            Creates a hook for this function using an alternative delegate/function pointer specified by <typeparamref name="TFunctionType"/>.
            Use only in .NET 5 and above with methods declared [UnmanagedCallersOnly].
            </summary>
            <param name="type">The type containing the method. Use "typeof()"</param>
            <param name="methodName">The name of the method. Use nameof()</param>
            <param name="minHookLength">Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.HookAs``1(System.Type,System.String)">
            <summary>
            Creates a hook for this function using an alternative delegate/function pointer specified by <typeparamref name="TFunctionType"/>.
            Use only in .NET 5 and above with methods declared [UnmanagedCallersOnly].
            </summary>
            <param name="type">The type containing the method. Use "typeof()"</param>
            <param name="methodName">The name of the method. Use nameof()</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.GetWrapper(System.IntPtr@)">
            <summary>
            Creates a wrapper function which allows you to call a function with a custom calling
            convention using the convention of <typeparamref name="TFunction"/>.
            </summary>
            <param name="wrapperAddress">Native address of the wrapper used to call the original function.</param>
            <remarks>The return value of this function is cached. Multiple calls will return same value.</remarks>
            <returns>A delegate for the function, ready to be called.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.GetWrapper">
            <summary>
            Creates a wrapper function which allows you to call a function with a custom calling
            convention using the convention of <typeparamref name="TFunction"/>.
            </summary>
            <remarks>The return value of this function is cached. Multiple calls will return same value.</remarks>
            <returns>A delegate for this function, ready to be called.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.MakeAsmHook(System.String[],Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour,System.Int32)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">
                The assembly code to execute, in FASM syntax.
                (Should start with use32/use64)
            </param>
            <param name="behaviour">Defines what should be done with the original code that was replaced with the JMP instruction.</param>
            <param name="hookLength">Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunction`1.MakeAsmHook(System.Byte[],Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour,System.Int32)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">The assembly code to execute, precompiled.</param>
            <param name="behaviour">Defines what should be done with the original code that was replaced with the JMP instruction.</param>
            <param name="hookLength">Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.IFunctionPtr`1">
            <summary>
            Utility interface for working with pointers to functions with non-standard conventions.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IFunctionPtr`1.FunctionPointer">
            <summary>
            The address of the pointer in memory with which this class was instantiated with.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IFunctionPtr`1.Item(System.Int32)">
            <summary>
            Returns a delegate instance for a function at a specified index of the pointer array.
            Only use this if all functions in VTable use same delegate instance.
            </summary>
            <param name="index">Array index of pointer to function.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunctionPtr`1.GetFunctionAddress(System.Int32)">
            <summary>
            Address of the function to which the pointer is currently pointing to.
            </summary>
            <param name="index">Index of the function.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IFunctionPtr`1.GetDelegate(System.Int32)">
            <summary>
            Retrieves an delegate instance which can be used to call the function behind the function pointer.
            </summary>
            <returns>Null if the pointer is zero; else a callable delegate.</returns>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.IHook">
            <summary/>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IHook.IsHookEnabled">
            <summary>
            Returns true if the hook is enabled and currently functional, else false.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IHook.IsHookActivated">
            <summary>
            Returns true if the hook has been activated.
            The hook may only be activated once.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IHook.OriginalFunctionAddress">
            <summary>
            The address to call if you wish to call the <see cref="P:Reloaded.Hooks.Definitions.IHook`1.OriginalFunction"/>.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IHook.OriginalFunctionWrapperAddress">
            <summary>
            The address of the wrapper used to call the <see cref="P:Reloaded.Hooks.Definitions.IHook`1.OriginalFunction"/>.
            If no wrapper was generated, this value is the same as <see cref="P:Reloaded.Hooks.Definitions.IHook.OriginalFunctionAddress"/>
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IHook.Activate">
             <summary>
             Performs a one time activation of the hook, making the necessary memory writes to permanently commit the hook.
             </summary>
             <remarks>
                 This function should be called after instantiation as soon as possible,
                 preferably in the same line as instantiation.
            
                 This class exists such that we don't run into concurrency issues on
                 attaching to other processes whereby the following happens:
            
                 A. Original process calls a function that was just hooked.
                 B. Create function has not yet returned, and <see cref="P:Reloaded.Hooks.Definitions.IHook`1.OriginalFunction"/> is unassigned.
                 C. Hook tried to call <see cref="P:Reloaded.Hooks.Definitions.IHook`1.OriginalFunction"/>. <see cref="T:System.NullReferenceException"/>.
             </remarks>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IHook.Disable">
            <summary>
            Temporarily disables the hook, causing all functions re-routed to your own function to be re-routed back to the original function instead.
            </summary>
            <remarks>This is implemented in such a fashion that the hook shall never touch C# code.</remarks>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IHook.Enable">
            <summary>
            Re-enables the hook if it has been disabled, causing all functions to be once again re-routed to your own function.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.IHook`1">
            <summary/>
            <typeparam name="TFunction">A valid delegate type or struct representing a function pointer.</typeparam>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IHook`1.OriginalFunction">
            <summary>
            Allows you to call the original function that was hooked.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IHook`1.ReverseWrapper">
            <summary>
            The reverse function wrapper that allows us to call the C# function
            as if it were to be of another calling convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IHook`1.IsHookEnabled">
            <inheritdoc cref="P:Reloaded.Hooks.Definitions.IHook.IsHookEnabled"/>>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IHook`1.IsHookActivated">
            <inheritdoc cref="P:Reloaded.Hooks.Definitions.IHook.IsHookActivated"/>>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IHook`1.OriginalFunctionAddress">
            <inheritdoc cref="P:Reloaded.Hooks.Definitions.IHook.OriginalFunctionAddress"/>>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IHook`1.OriginalFunctionWrapperAddress">
            <inheritdoc cref="P:Reloaded.Hooks.Definitions.IHook.OriginalFunctionWrapperAddress"/>>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IHook`1.Activate">
            <inheritdoc cref="M:Reloaded.Hooks.Definitions.IHook.Activate"/>>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IHook`1.Disable">
            <inheritdoc cref="M:Reloaded.Hooks.Definitions.IHook.Disable"/>>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IHook`1.Enable">
            <inheritdoc cref="M:Reloaded.Hooks.Definitions.IHook.Enable"/>>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.Internal.Misc">
            <summary>
            Miscellaneous Functions
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.Internal.Misc.TryGetAttribute``2(``1@)">
            <summary>
            Attempts to find a given attribute for a given generic type
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.Internal.Misc.TryGetAttributeOrDefault``2">
            <summary>
            Attempts to find a given attribute for a given generic type.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.IReloadedHooks">
            <summary>
            An interface providing high level functionality for the Reloaded.Hooks library.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateFunction``1(System.Int64)">
            <summary>
            Constructs an <see cref="T:Reloaded.Hooks.Definitions.IFunction`1"/>.
            Utility class which allows you to more easily hook or call a native function.
            </summary>
            <param name="address">The address of the function.</param>
            <typeparam name="TFunction">The delegate type of the function.</typeparam>
            <returns>The function.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateHook``1(``0,System.Int64)">
            <summary>
            Creates a hook for a function at a given address.
            </summary>
            <param name="function">The function to detour the original function to.</param>
            <param name="functionAddress">The address of the function to hook.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateHook``1(System.Void*,System.Int64)">
            <summary>
            Creates a hook for a function at a given address.
            </summary>
            <param name="targetAddress">The address to redirect the function to.</param>
            <param name="functionAddress">The address of the function to hook.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateHook``1(``0,System.Int64,System.Int32)">
            <summary>
            Creates a hook for a function at a given address.
            </summary>
            <param name="function">The function to detour the original function to.</param>
            <param name="functionAddress">The address of the function to hook.</param>
            <param name="minHookLength">[Default: -1] Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateHook``1(System.Void*,System.Int64,System.Int32)">
            <summary>
            Creates a hook for a function at a given address.
            </summary>
            <param name="targetAddress">The address to redirect the function to.</param>
            <param name="functionAddress">The address of the function to hook.</param>
            <param name="minHookLength">[Default: -1] Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateHook``1(``0,System.Int64,System.Int32,Reloaded.Hooks.Definitions.FunctionHookOptions)">
            <summary>
            Creates a hook for a function at a given address.
            </summary>
            <param name="function">The function to detour the original function to.</param>
            <param name="functionAddress">The address of the function to hook.</param>
            <param name="minHookLength">[Default: -1] Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
            <param name="options">Options which control the hook generation procedure.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateHook``1(System.Void*,System.Int64,System.Int32,Reloaded.Hooks.Definitions.FunctionHookOptions)">
            <summary>
            Creates a hook for a function at a given address.
            </summary>
            <param name="targetAddress">The address to redirect the function to.</param>
            <param name="functionAddress">The address of the function to hook.</param>
            <param name="minHookLength">[Default: -1] Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
            <param name="options">Options which control the hook generation procedure.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateHook``1(System.Type,System.String,System.Int64,System.Int32,Reloaded.Hooks.Definitions.FunctionHookOptions)">
            <summary>
            Creates a hook detouring the provided function to a given function.
            Use only in .NET 5 and above with methods declared [UnmanagedCallersOnly].
            </summary>
            <param name="type">The type containing the method. Use "typeof()"</param>
            <param name="methodName">The name of the method. Use nameof()</param>
            <param name="functionAddress">The address of the function to hook.</param>
            <param name="minHookLength">[Default: -1] Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
            <param name="options">Options which control the hook generation procedure.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateHook``1(System.Type,System.String,System.Int64,System.Int32)">
            <summary>
            Creates a hook detouring the provided function to a given function.
            Use only in .NET 5 and above with methods declared [UnmanagedCallersOnly].
            </summary>
            <param name="type">The type containing the method. Use "typeof()"</param>
            <param name="methodName">The name of the method. Use nameof()</param>
            <param name="functionAddress">The address of the function to hook.</param>
            <param name="minHookLength">[Default: -1] Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateHook``1(System.Type,System.String,System.Int64)">
            <summary>
            Creates a hook detouring the provided function to a given function.
            Use only in .NET 5 and above with methods declared [UnmanagedCallersOnly].
            </summary>
            <param name="type">The type containing the method. Use "typeof()"</param>
            <param name="methodName">The name of the method. Use nameof()</param>
            <param name="functionAddress">The address of the function to hook.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateWrapper``1(System.Int64,System.IntPtr@)">
            <summary>
            Creates a wrapper function which allows you to call a function with a custom calling convention using the calling convention of
            <typeparamref name="TFunction"/>.
            </summary>
            <param name="functionAddress">Address of the function to create a wrapper for.</param>
            <param name="wrapperAddress">Address of the wrapper used to call the original function.</param>
            <returns>The function ready to be called.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateWrapper``1(System.Int64)">
            <summary>
            Creates a wrapper function which allows you to call a function with a custom calling
            convention using the convention of <typeparamref name="TFunction"/>.
            </summary>
            <param name="functionAddress">Address of the function to create a wrapper for.</param>
            <returns>Function pointer to the wrapper in memory you can call using <typeparamref name="TFunction"/>'s calling convention.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateNativeWrapperX86``1(System.IntPtr,Reloaded.Hooks.Definitions.X86.IFunctionAttribute)">
            <summary>
            Creates a wrapper function which allows you to call a function with a custom calling
            convention using the convention of <typeparamref name="TFunction"/>.
            </summary>
            <param name="functionAddress">The address of the function.</param>
            <param name="fromConvention">Describes the calling convention of the function to wrap.</param>
            <returns>Function pointer to the wrapper in memory you can call using <typeparamref name="TFunction"/>'s calling convention.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateNativeWrapperX86``1(System.IntPtr,Reloaded.Hooks.Definitions.X86.IFunctionAttribute,Reloaded.Hooks.Definitions.X86.IFunctionAttribute)">
            <summary>
            Creates a wrapper function which allows you to call a function with a custom calling
            convention using the convention of <typeparamref name="TFunction"/>.
            </summary>
            <param name="functionAddress">The address of the function using <paramref name="fromConvention"/>.</param>
            <param name="fromConvention">The calling convention to convert to <paramref name="toConvention"/>. This is the convention of the function (<paramref name="functionAddress"/>) called.</param>
            <param name="toConvention">The target convention to which convert to <paramref name="fromConvention"/>. This is the convention of the function returned.</param>
            <returns>Address of the wrapper in memory you can call.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateNativeWrapperX64``1(System.IntPtr,Reloaded.Hooks.Definitions.X64.IFunctionAttribute,Reloaded.Hooks.Definitions.X64.IFunctionAttribute)">
            <summary>
            Creates a wrapper function converting a call to a source calling convention to a given target calling convention.
            </summary>
            <param name="functionAddress">The address of the function using <paramref name="fromConvention"/>.</param>
            <param name="fromConvention">The calling convention to convert to <paramref name="toConvention"/>. This is the convention of the function (<paramref name="functionAddress"/>) called.</param>
            <param name="toConvention">The target convention to which convert to <paramref name="fromConvention"/>. This is the convention of the function returned.</param>
            <returns>Address of the wrapper in memory you can call.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateReverseWrapper``1(``0)">
            <summary>
            Creates a wrapper function with a custom calling convention which calls the supplied function.
            </summary>
            <remarks>
                Please keep a reference to this class as long as you are using it (if <typeparamref name="TFunction"/> is a delegate type).
                Otherwise Garbage Collection will break the native function pointer to your C# function
                resulting in a spectacular crash if it is still used anywhere.
            </remarks>
            <param name="function">The function to be called by the wrapper.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateReverseWrapper``1(System.IntPtr)">
            <summary>
            Creates a wrapper function with a custom calling convention which calls the supplied function.
            </summary>
            <remarks>
                Please keep a reference to this class as long as you are using it (if <typeparamref name="TFunction"/> is a delegate type).
                Otherwise Garbage Collection will break the native function pointer to your C# function
                resulting in a spectacular crash if it is still used anywhere.
            </remarks>
            <param name="function">Pointer of native function to wrap.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.VirtualFunctionTableFromObject(System.IntPtr,System.Int32)">
            <summary>
            Initiates a virtual function table from an object address in memory.
            An assumption is made that the virtual function table pointer is the first parameter.
            </summary>
            <param name="objectAddress">
                The memory address at which the object is stored.
                The function will assume that the first entry is a pointer to the virtual function
                table, as standard with C++ code.
            </param>
            <param name="numberOfMethods">
                The number of methods contained in the virtual function table.
                For enumerables, you may obtain this value as such: Enum.GetNames(typeof(MyEnum)).Length; where
                MyEnum is the name of your enumerable.
            </param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.VirtualFunctionTableFromAddress(System.IntPtr,System.Int32)">
            <summary>
            Initiates a virtual function table given the address of the first function in memory.
            </summary>
            <param name="tableAddress">
                The memory address of the first entry (function pointer) of the virtual function table.
            </param>
            <param name="numberOfMethods">
                The number of methods contained in the virtual function table.
                For enumerables, you may obtain this value as such: Enum.GetNames(typeof(MyEnum)).Length; where
                MyEnum is the name of your enumerable.
            </param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateFunctionPtr``1(System.UInt64)">
            <summary>
            Creates a pointer to a native function.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.String[],System.Int64)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">
                The assembly code to execute, in FASM syntax.
                (Should start with use32/use64)
            </param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.String,System.Int64)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">
                The assembly code to execute, in FASM syntax.
                (Should start with use32/use64)
            </param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.Byte[],System.Int64)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">The assembly code to execute, precompiled.</param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.String[],System.Int64,Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">
                The assembly code to execute, in FASM syntax.
                (Should start with use32/use64)
            </param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
            <param name="behaviour">Defines what should be done with the original code that was replaced with the JMP instruction.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.String,System.Int64,Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">
                The assembly code to execute, in FASM syntax.
                (Should start with use32/use64)
            </param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
            <param name="behaviour">Defines what should be done with the original code that was replaced with the JMP instruction.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.Byte[],System.Int64,Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">The assembly code to execute, precompiled.</param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
            <param name="behaviour">Defines what should be done with the original code that was replaced with the JMP instruction.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.String[],System.Int64,Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour,System.Int32)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">
                The assembly code to execute, in FASM syntax.
                (Should start with use32/use64)
            </param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
            <param name="behaviour">Defines what should be done with the original code that was replaced with the JMP instruction.</param>
            <param name="hookLength">Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode. Default: -1</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.String,System.Int64,Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour,System.Int32)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">
                The assembly code to execute, in FASM syntax.
                (Should start with use32/use64)
            </param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
            <param name="behaviour">Defines what should be done with the original code that was replaced with the JMP instruction.</param>
            <param name="hookLength">Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode. Default: -1</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.Byte[],System.Int64,Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour,System.Int32)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">The assembly code to execute, precompiled.</param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
            <param name="behaviour">Defines what should be done with the original code that was replaced with the JMP instruction.</param>
            <param name="hookLength">Optional explicit length of hook. Use only in rare cases where auto-length check overflows a jmp/call opcode. Default: -1</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.String[],System.Int64,Reloaded.Hooks.Definitions.AsmHookOptions)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">
                The assembly code to execute, in FASM syntax.
                (Should start with use32/use64)
            </param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
            <param name="options">Controls the generation behaviour of assembly hooks.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.String,System.Int64,Reloaded.Hooks.Definitions.AsmHookOptions)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">
                The assembly code to execute, in FASM syntax.
                (Should start with use32/use64)
            </param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
            <param name="options">Controls the generation behaviour of assembly hooks.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.CreateAsmHook(System.Byte[],System.Int64,Reloaded.Hooks.Definitions.AsmHookOptions)">
            <summary>
            Creates a cheat engine style hook, replacing instruction(s) with a JMP to a user provided set of ASM instructions (and optionally the original ones).
            </summary>
            <param name="asmCode">The assembly code to execute, precompiled.</param>
            <param name="functionAddress">The address of the function or mid-function to hook.</param>
            <param name="options">Controls the generation behaviour of assembly hooks.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooks.HookedVirtualFunctionTableFromObject(System.IntPtr,System.Int32)">
            <summary>
            Hooks an object's virtual function table from an object address in memory.
            Only this object is hooked, other objects are unaffected.
            
            An assumption is made that the virtual function table pointer is the first parameter of the object.
            This method hooks the virtual function table pointer by copying the object's virtual function table
            and changing the objects virtual function table pointer to the address of the copy.
            
            After calling this, individual functions must be hooked by calling CreateFunctionHook.
            </summary>
            <param name="objectAddress">
                The memory address at which the object is stored.
                The function will assume that the first entry is a pointer to the virtual function
                table, as standard with C++ code.
            </param>
            <param name="numberOfMethods">
                The number of methods contained in the virtual function table.
                For enumerables, you may obtain this value as such: Enum.GetNames(typeof(MyEnum)).Length; where
                MyEnum is the name of your enumerable.
                Make sure this number is at least as big as your target vtable, 
                as we need to copy -all- of the vtable function pointers.
            </param>
            <returns></returns>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IReloadedHooks.Utilities">
            <summary>
            Provides access to various useful utilities.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.IReloadedHooksUtilities">
            <summary>
            A user facing interface to obtain access to utility functions.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.AssembleAbsoluteJump(System.IntPtr,System.Boolean)">
            <summary>
            Assembles an absolute jump to a user specified address.
            </summary>
            <param name="target">The target memory location to jump to.</param>
            <param name="is64bit">True to generate x64 code, else false (x86 code).</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.AssemblePushReturn(System.IntPtr,System.Boolean)">
            <summary>
            Assembles a push + return combination to a given target address.
            </summary>
            <param name="target">The target memory location to jump to.</param>
            <param name="is64bit">True to generate x64 code, else false (x86 code).</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.AssembleRelativeJump(System.IntPtr,System.Boolean)">
            <summary>
            Assembles a relative (to EIP/RIP) jump by a user specified offset.
            </summary>
            <param name="relativeJumpOffset">Offset relative to EIP/RIP to jump to.</param>
            <param name="is64bit">True to generate x64 code, else false (x86 code).</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.AssembleRelativeJump(System.IntPtr,System.IntPtr,System.Boolean)">
            <summary>
            Assembles a relative (to EIP/RIP) jump by a user specified offset.
            </summary>
            <param name="currentAddress">Address of the current instruction.</param>
            <param name="targetAddress">The address to jump to.</param>
            <param name="is64bit">True to generate x64 code, else false (x86 code).</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetAbsoluteJumpMnemonics(System.IntPtr,System.Boolean)">
            <summary>
            Gets the sequence of assembly instructions required to assemble an absolute jump to a user specified address.
            </summary>
            <param name="target">The target memory location to jump to.</param>
            <param name="is64bit">True to generate x64 code, else false (x86 code).</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetAbsoluteCallMnemonics(System.IntPtr,System.Boolean)">
            <summary>
            Gets the sequence of assembly instructions required to assemble an absolute call to a user specified address.
            </summary>
            <param name="target">The target memory location to jump to.</param>
            <param name="is64bit">True to generate x64 code, else false (x86 code).</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetAbsoluteJumpMnemonics``1(``0,Reloaded.Hooks.Definitions.IReverseWrapper{``0}@)">
            <summary>
            Gets the sequence of assembly instructions required to assemble an absolute jump to a C# function address.
            </summary>
            <param name="function">The C# function to create a jump to.</param>
            <param name="reverseWrapper">
                The native reverse wrapper used to call your function.
                Please keep a reference to this class as long as you are using the generated code.
                i.e. make it a class/struct member on heap.
            </param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetAbsoluteCallMnemonics``1(``0,Reloaded.Hooks.Definitions.IReverseWrapper{``0}@)">
            <summary>
            Gets the sequence of assembly instructions required to assemble an absolute call to a C# function address.
            </summary>
            <param name="function">The C# function to create a jump to.</param>
            <param name="reverseWrapper">
                The native reverse wrapper used to call your function.
                Please keep a reference to this class as long as you are using the generated code.
                i.e. make it a class/struct member on heap.
            </param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetPushReturnMnemonics(System.IntPtr,System.Boolean)">
            <summary>
            Gets the sequence of assembly instructions required to assemble an absolute jump to a user specified address.
            </summary>
            <param name="target">The target memory location to jump to.</param>
            <param name="is64bit">True to generate x64 code, else false (x86 code).</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetRelativeJumpMnemonics(System.IntPtr,System.Boolean)">
            <summary>
            Gets the sequence of assembly instructions required to assemble a relative jump to the current instruction pointer.
            </summary>
            <param name="relativeJumpOffset">Offset relative to EIP/RIP to jump to.</param>
            <param name="is64bit">True to generate x64 code, else false (x86 code).</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.InsertJump(System.Byte[],System.Boolean,System.Int64,System.Int64,System.Int64)">
            <summary>
            Appends an absolute jump to the supplied opcodes and assembles the result, returning a pointer.
            </summary>
            <param name="jumpTarget">The address to jump to.</param>
            <param name="opcodes">Bytes representing existing assembly instructions.</param>
            <param name="is64bit">True for x64 else x86</param>
            <param name="targetAddress">[Optional] Target address within of which the wrapper should be placed in <paramref name="maxDisplacement"/> range.</param>
            <param name="maxDisplacement">Maximum distance from the <paramref name="targetAddress"/></param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetHookLength(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Retrieves the length of the hook for trampoline, mid-function hooks etc.
            </summary>
            <param name="hookAddress">The address that is to be hooked.</param>
            <param name="hookLength">The minimum length of the hook, the length of our assembled bytes for the hook.</param>
            <param name="is64Bit">True if 64bit, else false.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetNumberofParameters(System.Type)">
            <summary>
            Retrieves the number of parameters for a specific delegate Type.
            </summary>
            <param name="delegateType">A Type extracted from a Delegate.</param>
            <returns>Number of parameters for the supplied delegate type.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetNumberofParametersWithoutFloats(System.Type)">
            <summary>
            Retrieves the number of parameters for a specific delegate Type.
            Ignores float and double parameters.
            </summary>
            <param name="delegateType">A Type extracted from a Delegate.</param>
            <returns>Number of parameters for the supplied delegate type, without floats.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetNumberofParameters``1">
            <summary>
            Retrieves the number of parameters for a type that inherits from <see cref="T:Reloaded.Hooks.Definitions.Structs.IFuncPtr"/>.
            Otherwise defaults to checking by type, assuming the type is a <see cref="T:System.Delegate"/>
            </summary>
            <typeparam name="TFunction">Type that inherits from <see cref="T:Reloaded.Hooks.Definitions.Structs.IFuncPtr"/> or contains a field that inherits from <see cref="T:Reloaded.Hooks.Definitions.Structs.IFuncPtr"/>.</typeparam>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetNumberofParametersWithoutFloats``1">
            <summary>
            Retrieves the number of parameters for a type that inherits from <see cref="T:Reloaded.Hooks.Definitions.Structs.IFuncPtr"/>.
            Otherwise defaults to checking by type, assuming the type is a <see cref="T:System.Delegate"/>
            Ignores float and double parameters.
            </summary>
            <typeparam name="TFunction">Type that inherits from <see cref="T:Reloaded.Hooks.Definitions.Structs.IFuncPtr"/> or contains a field that inherits from <see cref="T:Reloaded.Hooks.Definitions.Structs.IFuncPtr"/>.</typeparam>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.PushCdeclCallerSavedRegisters">
            <summary>
            A macro for "push eax\npush ecx\npush edx" that preserves all CDECL caller saved registers before
            a function call.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.PopCdeclCallerSavedRegisters">
            <summary>
            A macro for "pop edx\npop ecx\npop eax" for safely restoring caller saved registers after a function call.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.WritePointer(System.IntPtr)">
            <summary>
            Allocates a pointer to a given target address in unmanaged, non-reclaimable memory.
            </summary>
            <param name="target">The target address/value the pointer is pointing to</param>
            <returns>Address of the pointer.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetFunctionPointer(System.Type,System.String)">
            <summary>
            Gets a function pointer to a static managed method. Avoids nasty function pointer casting.
            Use only in .NET 5 and above with methods declared [UnmanagedCallersOnly].
            </summary>
            <param name="type">Type where the method can be found.</param>
            <param name="name">Name of the method in question.</param>
            <returns></returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IReloadedHooksUtilities.GetRelativeJumpMinMax(System.Int64,System.Int64)">
            <summary>
            Gets the minimum and maximum address possible with a relative jump.
            </summary>
            <param name="targetAddress">Address we are jumping from.</param>
            <param name="maxDisplacement">Maximum distance we can jump.</param>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.IReverseWrapper">
            <summary/>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IReverseWrapper.NativeFunctionPtr">
            <summary> Pointer to the function that gets executed inside the wrapper, either native or C#. </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IReverseWrapper.WrapperPointer">
            <summary> A pointer to our wrapper, which calls the internal method as if it were to be of another convention. </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.IReverseWrapper`1">
            <summary/>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IReverseWrapper`1.CSharpFunction">
            <summary> Copy of C# function behind the pointer. </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IReverseWrapper`1.NativeFunctionPtr">
            <inheritdoc cref="P:Reloaded.Hooks.Definitions.IReverseWrapper.NativeFunctionPtr"/>>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IReverseWrapper`1.WrapperPointer">
            <inheritdoc cref="P:Reloaded.Hooks.Definitions.IReverseWrapper.WrapperPointer"/>>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.IVirtualFunctionTable">
            <summary/>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IVirtualFunctionTable.TableEntries">
            <summary>
            Stores a list of the individual table addresses for this Virtual Function Table.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.IVirtualFunctionTable.Item(System.Int32)">
            <summary>
            An indexer override allowing for individual Virtual Function Table
            entries to be easier accessed.
            </summary>
            <param name="i">The individual entry in the virtual function table.</param>
            <returns>The individual corresponding virtual function table entry.</returns>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IVirtualFunctionTable.CreateWrapperFunction``1(System.Int32)">
            <summary>
            Generates a wrapper function for an individual virtual function table entry.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.IVirtualFunctionTable.CreateFunctionHook``1(System.Int32,``0)">
            <summary>
            Hooks an individual virtual function table entry in a virtual function table.
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`1.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`1.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`1.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`1.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`1.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`1.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`1.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`2.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`2.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`2.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`2.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`2.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`2.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`2.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`3.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`3.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`3.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`3.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`3.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`3.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`3.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`4.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`4.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`4.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`4.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`4.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`4.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`4.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`5.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`5.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`5.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`5.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`5.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`5.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`5.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`6.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`6.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`6.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`6.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`6.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`6.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`6.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`7.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`7.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`7.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`7.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`7.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`7.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`7.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`8.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`8.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`8.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`8.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`8.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`8.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`8.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`9.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`9.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`9.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`9.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`9.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`9.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`9.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`10.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`10.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`10.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`10.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`10.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`10.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`10.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`11.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`11.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`11.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`11.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`11.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`11.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`11.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`12.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`12.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`12.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`12.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`12.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`12.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`12.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`13.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`13.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`13.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`13.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`13.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`13.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`13.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`14.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`14.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`14.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`14.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`14.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`14.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`14.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`15.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`15.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`15.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`15.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`15.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`15.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`15.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`16.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`16.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`16.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`16.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`16.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`16.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`16.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`17.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`17.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`17.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`17.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`17.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`17.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`17.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`18.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`18.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`18.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`18.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`18.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`18.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`18.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="F:Reloaded.Hooks.Definitions.Structs.FuncPtr`19.funcPtr">
            <summary>
            Raw pointer to the function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`19.Invoke">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`19.InvokeAsCdecl">
            <summary>
            Calls the underlying function using the Cdecl convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`19.InvokeAsStdcall">
            <summary>
            Calls the underlying function using the Stdcall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`19.InvokeAsThiscall">
            <summary>
            Calls the underlying function using the Thiscall convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`19.NumberOfParameters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.FuncPtr`19.NumberOfParametersWithoutFloats">
            <inheritdoc />
        </member>
        <member name="T:Reloaded.Hooks.Definitions.Structs.IFuncPtr">
            <summary>
            Interface implemented by all function pointers.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.IFuncPtr.NumberOfParameters">
            <summary>
            Gets the number of generic parameters.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.Structs.IFuncPtr.NumberOfParametersWithoutFloats">
            <summary>
            Gets the number of generic parameters, excluding float numbers.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.Structs.FuncPtr">
            <summary/>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.Structs.FuncPtr.GetNumberOfParameters(System.Type)">
            <summary>
            Gets the number of parameters.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.Structs.FuncPtr.GetNumberOfParametersWithoutFloats(System.Type)">
            <summary>
            Gets the number of parameters.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.Structs.Void">
            <summary>
            Empty structure to be used in place of `Void` as return type in function pointers.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.TableEntry">
            <summary>
            A structure type which an individual virtual function table entry.
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.TableEntry.EntryAddress">
            <summary>
            The address in process memory where the VTable entry has been found.
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.TableEntry.FunctionPointer">
            <summary>
            The value of the individual entry in process memory for the VTable entry pointing to a function.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.X64.CallingConventions">
            <summary>
            This class provides information on various commonly seen calling conventions.
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.X64.CallingConventions.Microsoft">
             <summary>
             Parameters are passed in the order of RCX, RDX, R8, R9 registers, left to right.
             Remaining parameters are passed right to left onto the function pushing onto the stack.
            
             Caller's responsibility to create allocate 32 bytes of "shadow space" on the stack before calling function.
             
             Calling function pops its own arguments from the stack if necessary and uses the "shadow space"
             as storage for the individual parameters to free registers if necessary.
            
             The calling function must manually restore the stack to previous state
             
             ReloadedFunction Attribute:
                 TargetRegisters:    RCX, RDX, R8, R9
                 ReturnRegister:     RAX    
                 Cleanup:            Caller
             </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.X64.CallingConventions.SystemV">
            <summary>
            Parameters are passed in the order of RDI, RSI, RDX, RCX, R8, R9 registers, left to right.
            Remaining parameters are passed right to left onto the function pushing onto the stack.
            
            No necessity of "shadow space" is provided, though Reloaded will provide it anyway for
            compatibility with custom conventions.
            
            ReloadedFunction Attribute:
                TargetRegisters:    RDI, RSI, RDX, RCX, R8, R9 
                ReturnRegister:     EAX    
                Cleanup:            Callee
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.X64.CallingConventions.Custom">
            <summary>
            Placeholder for custom, compiler optimized calling conventions which don't 
            follow any particular standard.
            
            ReloadedFunction Attribute:
                TargetRegisters:    Depends on Function
                ReturnRegister:     Depends on Function
                Cleanup:            Depends on Function
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.X64.FunctionAttribute">
            <summary>
            Stores function information for custom functions.
            See <see cref="T:Reloaded.Hooks.Definitions.X64.CallingConventions" /> for information common calling convention settings.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X64.FunctionAttribute.SourceRegisters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X64.FunctionAttribute.ReturnRegister">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X64.FunctionAttribute.ShadowSpace">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X64.FunctionAttribute.CalleeSavedRegisters">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X64.FunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X64.FunctionAttribute.Register[],Reloaded.Hooks.Definitions.X64.FunctionAttribute.Register,System.Boolean)">
            <summary>
            Initializes a ReloadedFunction with its default parameters supplied in the constructor.
            </summary>
            <param name="sourceRegisters">Registers in left to right parameter order passed to the custom function.</param>
            <param name="returnRegister">The register that the function returns its value in.</param>
            <param name="shadowSpace">
                [Default = true] Defines whether the function to be called or hooked expects "Shadow Space".
                Shadow space allocates 32 bytes of memory onto the stack before calling the function. See class definition for more details.
            </param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X64.FunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X64.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X64.FunctionAttribute.Register,System.Boolean)">
            <summary>
            Initializes a ReloadedFunction with its default parameters supplied in the constructor.
            </summary>
            <param name="sourceRegister">Registers in left to right parameter order passed to the custom function.</param>
            <param name="returnRegister">The register that the function returns its value in.</param>
            <param name="shadowSpace">
                [Default = true] Defines whether the function to be called or hooked expects "Shadow Space".
                Shadow space allocates 32 bytes of memory onto the stack before calling the function. See class definition for more details.
            </param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X64.FunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X64.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X64.FunctionAttribute.Register,System.Boolean,Reloaded.Hooks.Definitions.X64.FunctionAttribute.Register[])">
            <summary>
            Initializes a ReloadedFunction with its default parameters supplied in the constructor.
            </summary>
            <param name="sourceRegister">Registers in left to right parameter order passed to the custom function.</param>
            <param name="returnRegister">The register that the function returns its value in.</param>
            <param name="shadowSpace">
                [Default = true] Defines whether the function to be called or hooked expects "Shadow Space".
                Shadow space allocates 32 bytes of memory onto the stack before calling the function. See class definition for more details.
            </param>
            <param name="calleeSavedRegisters">A list of registers that should be preserved by this function.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X64.FunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X64.FunctionAttribute.Register[],Reloaded.Hooks.Definitions.X64.FunctionAttribute.Register,System.Boolean,Reloaded.Hooks.Definitions.X64.FunctionAttribute.Register[])">
            <summary>
            Initializes a ReloadedFunction with its default parameters supplied in the constructor.
            </summary>
            <param name="sourceRegisters">Registers in left to right parameter order passed to the custom function.</param>
            <param name="returnRegister">The register that the function returns its value in.</param>
            <param name="shadowSpace">
                [Default = true] Defines whether the function to be called or hooked expects "Shadow Space".
                Shadow space allocates 32 bytes of memory onto the stack before calling the function. See class definition for more details.
            </param>
            <param name="calleeSavedRegisters">A list of registers that should be preserved by this function.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X64.FunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X64.CallingConventions)">
            <summary>
            Initializes the ReloadedFunction using a preset calling convention.
            </summary>
            <param name="callingConvention">The calling convention preset to use for instantiating the ReloadedFunction.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X64.FunctionAttribute.GetAttribute``1">
            <summary>
            Retrieves a ReloadedFunction from a supplied delegate type.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.X64.IFunctionAttribute">
            <summary/>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X64.IFunctionAttribute.SourceRegisters">
            <summary>
            Registers in left to right parameter order passed to the custom function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X64.IFunctionAttribute.ReturnRegister">
            <summary>
            The register that the function returns its value in.
            This is typically rax.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X64.IFunctionAttribute.ShadowSpace">
            <summary>
            Defines whether the function to be called or hooked expects "Shadow Space".
            Shadow space allocates 32 bytes of memory onto the stack before calling the function, such that they
            may be used locally within the target function as storage.
            [Default] True: Microsoft X64 based calling conventions.
            False: SystemV-based calling conventions.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X64.IFunctionAttribute.CalleeSavedRegisters">
            <summary>
            Specifies all the registers whose values are expected to be preserved by the function.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.X86.CallingConventions">
            <summary>
            This class provides information on various commonly seen calling conventions and how
            to call functions utilising them.
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.X86.CallingConventions.Cdecl">
            <summary>
            Parameters are passed right to left onto the function pushing onto the stack.
            Calling function pops its own arguments from the stack. 
            (The calling function must manually restore the stack to previous state)
            
            ReloadedFunction Attribute:
                TargetRegisters:    N/A
                ReturnRegister:     EAX    
                Cleanup:            Caller
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.X86.CallingConventions.Stdcall">
            <summary>
            Parameters are passed right to left onto the function pushing onto the stack.
            Called function pops its own arguments from the stack.
            
            ReloadedFunction Attribute:
                TargetRegisters:    N/A
                ReturnRegister:     EAX    
                Cleanup:            Callee
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.X86.CallingConventions.Fastcall">
             <summary>
             The first two arguments are passed in from left to right into ECX and EDX.
             The others are passed in right to left onto stack.
            
             ReloadedFunction Attribute:
                 TargetRegisters:    ECX, EDX
                 ReturnRegister:     EAX    
                 Cleanup:            Caller
             
             Caller cleanup: If necessary, the stack is cleaned up by the caller.
             </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.X86.CallingConventions.MicrosoftThiscall">
             <summary>
             Variant of Stdcall where the pointer of the `this` object is passed into ECX and
             rest of the parameters passed as usual. The Callee cleans the stack.
            
             You should define your delegates with the (this) object pointer (IntPtr) as first parameter from the left.
             
             ReloadedFunction Attribute:
                 TargetRegisters:    ECX
                 ReturnRegister:     EAX
                 Cleanup:            Callee
             
             For GCC variant of Thiscall, use Cdecl.
             </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.X86.CallingConventions.GCCThiscall">
            <summary>
            A variant of CDECL whereby the first parameter is the pointer to the `this` object.
            Everything is otherwise the same.
            
            ReloadedFunction Attribute:
                TargetRegisters:    N/A
                ReturnRegister:     EAX    
                Cleanup:            Caller
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.X86.CallingConventions.Usercall">
            <summary>
            A name given to custom calling conventions by Hex-Rays (IDA) that are cleaned up by the caller.
            You should declare the <see cref="T:Reloaded.Hooks.Definitions.X86.FunctionAttribute"/> manually yourself.
            
            ReloadedFunction Attribute:
                TargetRegisters:    Depends on Function
                ReturnRegister:     Depends on Function
                Cleanup:            Caller
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.X86.CallingConventions.Userpurge">
            <summary>
            A name given to custom calling conventions by Hex-Rays (IDA) that are cleaned up by the callee.
            You should declare the <see cref="T:Reloaded.Hooks.Definitions.X86.FunctionAttribute"/> manually yourself.
            
            ReloadedFunction Attribute:
                TargetRegisters:    Depends on Function
                ReturnRegister:     Depends on Function
                Cleanup:            Callee
            </summary>
        </member>
        <member name="F:Reloaded.Hooks.Definitions.X86.CallingConventions.ClrCall">
            <summary>
            The calling convention internally used by the .NET runtime.
            Arguments are pushed to the stack LEFT TO RIGHT unlike other conventions,
            so please reverse the order of all parameters past the second one.
            ReloadedFunction Attribute:
                TargetRegisters:    ECX, EDX
                ReturnRegister:     EAX    
                Cleanup:            Callee
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.X86.FunctionAttribute">
            <summary>
            Stores function information for custom functions.
            See <see cref="T:Reloaded.Hooks.Definitions.X86.CallingConventions" /> for information common calling convention settings.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X86.FunctionAttribute.SourceRegisters">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X86.FunctionAttribute.ReturnRegister">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X86.FunctionAttribute.Cleanup">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X86.FunctionAttribute.ReservedStackSpace">
            <inheritdoc />
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X86.FunctionAttribute.CalleeSavedRegisters">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.FunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[],Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup,System.Int32)">
            <summary>
            Initializes a ReloadedFunction with its default parameters supplied in the constructor.
            </summary>
            <param name="sourceRegisters">Registers in left to right parameter order passed to the custom function.</param>
            <param name="returnRegister">The register that the function returns its value in.</param>
            <param name="stackCleanup">Defines the stack cleanup rule for the function. See <see cref="T:Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup"/> for more details.</param>
            <param name="reservedStackSpace">Allocates an extra amount of uninitialized (not zero-written) stack space for the function to use when calling. Required by some compiler optimized functions.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.FunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[],Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[],System.Int32)">
            <summary>
            Initializes a ReloadedFunction with its default parameters supplied in the constructor.
            </summary>
            <param name="sourceRegisters">Registers in left to right parameter order passed to the custom function.</param>
            <param name="returnRegister">The register that the function returns its value in.</param>
            <param name="stackCleanup">Defines the stack cleanup rule for the function. See <see cref="T:Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup"/> for more details.</param>
            <param name="calleeSavedRegisters">A list of registers that should be preserved by this function.</param>
            <param name="reservedStackSpace">Allocates an extra amount of uninitialized (not zero-written) stack space for the function to use when calling. Required by some compiler optimized functions.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.FunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup,System.Int32)">
            <summary>
            Initializes a ReloadedFunction with its default parameters supplied in the constructor.
            </summary>
            <param name="sourceRegister">Registers in left to right parameter order passed to the custom function.</param>
            <param name="returnRegister">The register that the function returns its value in.</param>
            <param name="stackCleanup">Defines the stack cleanup rule for the function. See <see cref="T:Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup"/> for more details.</param>
            <param name="reservedStackSpace">Allocates an extra amount of uninitialized (not zero-written) stack space for the function to use when calling. Required by some compiler optimized functions.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.FunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[],System.Int32)">
            <summary>
            Initializes a ReloadedFunction with its default parameters supplied in the constructor.
            </summary>
            <param name="sourceRegister">Registers in left to right parameter order passed to the custom function.</param>
            <param name="returnRegister">The register that the function returns its value in.</param>
            <param name="stackCleanup">Defines the stack cleanup rule for the function. See <see cref="T:Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup"/> for more details.</param>
            <param name="calleeSavedRegisters">A list of registers that should be preserved by this function.</param>
            <param name="reservedStackSpace">Allocates an extra amount of uninitialized (not zero-written) stack space for the function to use when calling. Required by some compiler optimized functions.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.FunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.CallingConventions)">
            <summary>
            Initializes the ReloadedFunction using a preset calling convention.
            </summary>
            <param name="callingConvention">The calling convention preset to use for instantiating the ReloadedFunction.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.FunctionAttribute.IsEquivalent(System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.FunctionAttribute.GetEquivalent(System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.FunctionAttribute.GetAttribute``1">
            <summary>
            Retrieves a ReloadedFunction attribute from a supplied delegate type.
            </summary>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.X86.IFunctionAttribute">
            <summary>
            Represents the details of an individual x86 calling convention.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X86.IFunctionAttribute.SourceRegisters">
            <summary>
            Registers in left to right parameter order passed to the custom function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X86.IFunctionAttribute.ReturnRegister">
            <summary>
            The register that the function returns its value in.
            This is typically eax.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X86.IFunctionAttribute.Cleanup">
            <summary>
            Defines the stack cleanup rule for the function.
            Callee: Stack pointer restored inside the function we are executing.
            Caller: Stack pointer restored in our own wrapper function.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X86.IFunctionAttribute.ReservedStackSpace">
            <summary>
            Used for allocating an extra amount of uninitialized (not zero-written) stack space 
            before calling the function. This is required by some compiler optimized functions.
            </summary>
        </member>
        <member name="P:Reloaded.Hooks.Definitions.X86.IFunctionAttribute.CalleeSavedRegisters">
            <summary>
            Specifies all the registers whose values are expected to be preserved by the function.
            </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.IFunctionAttribute.IsEquivalent(System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute)">
            <summary>
            Checks if the given attribute matches an already built-in convention.
            </summary>
            <param name="attribute">Existing supported attribute.</param>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.IFunctionAttribute.GetEquivalent(System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute)">
            <summary>
            If possible, gets an equivalent supported function attribute.
            </summary>
            <param name="attribute">Existing supported attribute.</param>
        </member>
        <member name="T:Reloaded.Hooks.Definitions.X86.ManagedFunctionAttribute">
             <summary>
             Overrides the expected calling convention of the native C# function called.
             This attribute is functionally equivalent to <see cref="T:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute"/> used with delegates; but for Hooks.
            
             This function only affects the <see cref="T:Reloaded.Hooks.Definitions.IHook"/> and <see cref="T:Reloaded.Hooks.Definitions.IReverseWrapper"/> APIs.
             </summary>
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.ManagedFunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[],Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.ManagedFunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[],Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[])">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.ManagedFunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.ManagedFunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[])">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.ManagedFunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[],Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.ManagedFunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[],Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.ManagedFunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.ManagedFunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register,Reloaded.Hooks.Definitions.X86.FunctionAttribute.StackCleanup,Reloaded.Hooks.Definitions.X86.FunctionAttribute.Register[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Reloaded.Hooks.Definitions.X86.ManagedFunctionAttribute.#ctor(Reloaded.Hooks.Definitions.X86.CallingConventions)">
            <inheritdoc />
        </member>
    </members>
</doc>
